<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>showPic</title>
    <url>/2023/05/20/showPic/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/apple.jpg"
                      alt="Test"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/book.jpg"
                      alt="Test"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://lrlflush.github.io/images/pexels.jpg"
                      alt="Test"
                ></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>learning</title>
    <url>/2023/05/20/learning/</url>
    <content><![CDATA[<h1 id="About-Learning"><a href="#About-Learning" class="headerlink" title="About Learning"></a>About Learning</h1><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/05/19/%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h4 id="Nmap检测版本和系统："><a href="#Nmap检测版本和系统：" class="headerlink" title="Nmap检测版本和系统："></a>Nmap检测版本和系统：</h4><h5 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h5><p>1、通过对设备或者防火墙的探测来审计它的安全性。</p>
<p>2、探测目标主机所开放的端口。</p>
<p>3、网络存储，网络映射，维护和资产管理。</p>
<p>4、通过识别新的服务器审计网络的安全性。</p>
<p>5、探测网络上的主机。</p>
<h5 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h5><p>nmap使用tcp&#x2F;ip协议栈指纹来识别不同的操作系统和设备。在RFC规范中，有些地方对TCP&#x2F;IP的实现并没有强制规定，由于不同的TCP&#x2F;IP方案中可能都有自己的特定方案。namp主要是根据这些细节上的差异来判断操作系统的类型。</p>
<h5 id="三-实验内容"><a href="#三-实验内容" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h5><p>主机探测：探测网络上的主机，例如列出响应TCP和ICMP请求、icmp请求、开放特别端口的主机。</p>
<p>端口扫描：探测目标主机所开放的端口。</p>
<p>版本检测：探测目标主机的网络服务，判断其服务名称及版本号。系统检测：探测目标主机的操作系统及网络设备的硬件特性。支持探测脚本的编写：使用Nmap的脚本引擎（NSE）和Lua编程语言。</p>
<h5 id="四-实验环境描述"><a href="#四-实验环境描述" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h5><p>1、靶机 带有环境 用户名密码为： msfadmin msfadmin2、攻击机 带有nmap工具 用户名密码为 root toor</p>
<h5 id="五-实验步骤"><a href="#五-实验步骤" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h5><p>1、进入H004003010metasploitable_1533886175_13虚拟机，输入ifconfig查看靶机和攻击机的ip地址。</p>
<p>靶机：</p>
<p>用户机：</p>
<p>2、在H004006001kali02输入nmap 172.16.1.252，用Nmap进行简单的扫描。Nmap 默认发送一个arp的ping数据包，来探测目标主机在1-10000范围内所开放的端口。</p>
<p>3、输入nmap -vv 172.16.1.252,用Nmap进行简单扫描，并对返回的结果详细描述输入。 -vv 参数设置对结果的详细输出。</p>
<p>4、输入nmap -sV 172.16.1.252指定让nmap进行版本侦测</p>
<p>5、输入nmap -version-intensity 3 172.16.1.252指定版本侦测强度为3，范围为0~9，数值越高，探测出的服务越准确，但是运行 时间比较长。</p>
<p>6、输入nmap -version-trace 172.16.1.252,显示出详细的版本侦测过程信息</p>
<p>7、输入nmap -O 172.16.1.252 ,nmap 通过目标开放的端口来探测主机所运行的操作系统类型。这是信息收集中很重要的一步，它可以帮助你找到特定操作系统上的含有漏洞的的服务。</p>
<p>8、输入nmap -osscan-guess 172.16.1.252大胆猜测对方的主机的系统类型，由此准确性会下降不少，但会尽可能多为用户提供给潜在的操作系统。</p>
<h4 id="Nmap之主机发现："><a href="#Nmap之主机发现：" class="headerlink" title="Nmap之主机发现："></a>Nmap之主机发现：</h4><h5 id="一-实验目的-1"><a href="#一-实验目的-1" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h5><p>1、通过对设备或者防火墙的探测来审计它的安全性。</p>
<p>2、探测目标主机所开放的端口。</p>
<p>3、网络存储，网络映射，维护和资产管理。</p>
<p>4、通过识别新的服务器审计网络的安全性。</p>
<p>5、探测网络上的主机。</p>
<h5 id="二-实验原理-1"><a href="#二-实验原理-1" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h5><p>与ping命令类似，发送探测包到目标主机，如果收到回复，那么说明目标主机是开启的，nmap支持十多种不同的主机探测方式，比如发送ICMP ECHO&#x2F;TIMESTAMP&#x2F;NETASK报文、发送TCPSYS&#x2F;ACK包、发送SCTP INIT&#x2F;ｃｏｏｋｉｅ-ECHO包，用户可以在不同的条件下灵活选用不不同的方式探测目标主机。</p>
<h5 id="三-实验内容-1"><a href="#三-实验内容-1" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h5><p>-sL :List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现</p>
<p>-sn ：Ping Scan 只进行主机发现，不进行端口扫描。</p>
<p>-Pn：将所有指定的主机视作开启，跳过主机发现的过程。</p>
<p>-PS&#x2F;PA&#x2F;PU&#x2F;PY[postlist]：使用TCPSYS&#x2F;ACK或SCTP INIT&#x2F;ECHO方式进行发现-PE&#x2F;PP&#x2F;PM:使用ICMP echo，timestamp，ａｎｄ netmask请求包发现主机，</p>
<p>-PO:使用IP协议包探测对方主机是否开启。</p>
<p>-n&#x2F;-R:-n表示不进行DNS解析，-R表示总进行DNS解析。</p>
<p>-dns-servers：指向DNS服务器。</p>
<p>-system-dns：指向使用系统的DNS服务器</p>
<p>-traceroute：追踪每个路由节点其中比较常用的是</p>
<p>-sn。表示只单独进行发现过程，</p>
<p>-Pn表示直接跳过主机发现而进行端口扫描等高级操作（如果已经明确确定目标主机已经开启，可用该选项）；</p>
<p>-n：如果不想使用DNS或revesr DNS解析，那么可以使用该选项。</p>
<h5 id="四-实验环境描述-1"><a href="#四-实验环境描述-1" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h5><p>1、靶机 用户名密码为 msfadmin msfadmin2、攻击机 用户名密码为 root toor靶机上面装有扫描的环境，攻击机上面装有nmap工具</p>
<h5 id="五-实验步骤-1"><a href="#五-实验步骤-1" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h5><p>1、进入H004003010metasploitable_1533886175_13进入靶机里面，输入ifconfig查看靶机和攻击机的ip地址。</p>
<p>主机：</p>
<p>靶机：</p>
<p>2、输入nmap -sn 172.16.1.175只进行主机发现，不进行端口扫描。</p>
<p>3、输入nmap -Pn 172.16.1.175，将所有指定的主机视作开启，跳过主机发现的过程。</p>
<p>4、输入nmap -Pn -v 172.16.1.175，将所有指定的主机视作开启，跳过主机发现的过程，并详细的显示所有结果。</p>
<p>5、输入nmap -PS 172.16.1.175使用TCP-SYS方式扫描，细的显示所有结果。</p>
<p>6、输入nmap -Pn -n 172.16.1.175使用TCP-SYS方式扫描， 且不进行DNS解析。</p>
<p>7、输入nmap -A 172.16.1.175 此选项设置包含了1-10000的端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测。</p>
<p>8、输入nmap -sV -v -O - Pn 172.16.1.175，-sV，代表进行版本侦测，-O 代表进行OS侦测，-pn将所有指定的主机视作开启，跳过主机发现的过程 ，-v表示详细的显示所有结果。</p>
<p>9、输入nmap -sP 172.16.1.0&#x2F;24 或者nmap -sP 172.16.1.1-255进行网段扫描</p>
<h4 id="Nmap之端口扫描"><a href="#Nmap之端口扫描" class="headerlink" title="Nmap之端口扫描"></a>Nmap之端口扫描</h4><h5 id="一-实验目的-2"><a href="#一-实验目的-2" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h5><p>1、通过对设备或者防火墙的探测来审计它的安全性。2、探测目标主机所开放的端口。3、网络存储，网络映射，维护和资产管理。4、通过识别新的服务器审计网络的安全性。5、探测网络上的主机。</p>
<h5 id="二-实验原理-2"><a href="#二-实验原理-2" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h5><p>1、Half-open scanning这是nmap默认的扫描方式，通常被称作半开放扫描（Half-open scanning ）。该方式发送SYN到目标端口，如果收到SYN&#x2F;ACK回复，那么判断端口是开放的；如果收到RST包，说明该端口是关闭的，如果没有收到回复，那么判断端口是被屏蔽的（Filtered）。因为该方式仅发送SYN包对目标主机的特定端口，但不建立的完整的TCP连接，所以相对比较隐蔽，而且效率比较高，适用范围广。</p>
<p>2、tcp connect使用系统网络API connect向目标主机的端口发起连接，如果无法连接，说明该端口关闭，该方式扫描速度比较慢，而且由于建立完整的TCP连接会在目标机上留下记录信息，不够隐藏，所以TCP connect是TCP SYN无法使用才考虑选择的方式。</p>
<p>3、tcp ACK scanning向目标主机的端口发送ack包，如果收到RST包，说明该端口没有被防火墙屏蔽，没有收到RST包，说明被屏蔽，该方式只能用于确定防火墙是否屏蔽某个端口，可以辅助TCP SYN的方式来判断目标主机防火墙的状况。</p>
<p>4、tcp FIN &#x2F;Xmas&#x2F;NULL scanning这三种扫描方式称为秘密扫描（Stsalthy Scan），因为相对比较隐藏，FIN扫描向目标主机的端口发送的TCP FIN包或Xmas tree包&#x2F;Null包，如果收不到对方RST回复包，那么说明该端口是关闭的，没有收到RST包说明端口可能是开放的或被屏蔽的。其中Xmas tree包是指fiags中FIN URG PUSI设置为1的tcp包，NULL包是指所有flags都为0的tcp包。</p>
<h5 id="三-实验内容-2"><a href="#三-实验内容-2" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h5><p>-sS&#x2F;sT&#x2F;sA&#x2F;sW&#x2F;sW :指定使用TCPSYN&#x2F;CONNECT()&#x2F;ACK&#x2F;window&#x2F;Maimon Scans的方式来对目标主机进行扫描</p>
<p>-sU ：指定使用UDP扫描方式确定目标主机的UDP端口状态。</p>
<p>-sN&#x2F;sF&#x2F;sX：指定使用TCP Null。FIN ａｎｄ Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。</p>
<p>-ssanflags&lt; flags &gt;:定制TCP包的flags。-sI:指定使用idle scan方式来扫描目标主机（前提是需要找到合适的zombie host）</p>
<p>-sY&#x2F;sZ：使用SCTP INIT&#x2F;ｃｏｏｋｉｅ-ECHO 来扫描SCTP协议端口的开放的情况。-s0：使用IP protocol 扫描确定目标支持的歇息类型。</p>
<p>-b&lt; FTP relay host&gt;:使用FTP bounce scan扫描方式-p &lt; port ranges&gt;：扫描指定端口如-p22；-p1-65535；-p U：53,111,137,T:21-192.168.1.18080,S:9 （ T代表TCP，U 代表UDP，S代表SCTP协议）</p>
<p>-F （Fast mode）快速模式，仅扫描TOP 100的端口</p>
<p>-r：不进行端口随记打乱的操作，（如无该参数，nmap会将要扫描的端口以随机顺序方式扫描，以让nmap的扫描不易被对方防火墙检测到）</p>
<p>-top-ports&lt; number &gt;:扫描开放概率最高的number个端口，默认情况下，nmap会扫描最有可能的1000个TCP端口-port-ratio&lt; ratio&gt;:扫描指定频率以上的端口，-sS表示使用TCP SYN方式扫描TCP端口，-sU表示扫描UDP端口，-T4表示时间级别配置4级，-top-ports 300表示扫描最有可能开放的300个端口（tcp和udp分别有300个端口）</p>
<h5 id="四-实验环境描述-2"><a href="#四-实验环境描述-2" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h5><p>1、靶机 用户名密码为：msfadmin msfadmin2、攻击机 用户名密码为：root toor</p>
<h5 id="五-实验步骤-2"><a href="#五-实验步骤-2" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h5><p>1、分别进入靶机、攻击机里使用ifconfig查看ip地址。</p>
<p>靶机</p>
<p>攻击机：</p>
<p>2、在H004006003kali02中输入nmap -sS 172.16.1.183,使用SYN方式进行扫描。</p>
<p>3、输入nmap -sU 172.16.1.183,使用UDP扫描方式确定目标主机的UDP端口状态.</p>
<p>4、输入nmap -F 172.16.1.183,使用快速扫描方式，仅扫描TOP 100的端口</p>
<p>5、输入nmap -v -sS -A -T4 172.16.1.183, 使用SYN扫描,在insane(5)的时间模板下,探测操作系统的类型和版本</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328083622190.png"
                      alt="image-20230328083622190"
                ></p>
<p>6、输入nmap -p1-100 172.16.1.183 nmap 默认扫描目标1-10000范围内的端口号。我们则可以通过参数-p 来设置我们将要扫描的端口号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328083720146.png"
                      alt="image-20230328083720146"
                ></p>
<p>7、输入nmap -p80,443,21,22,8080,25,35 172.16.1.183 ,只对80,443,1000,65534这几个特殊的端口进行扫描</p>
<p>8、输入nmap –traceroute 172.16.1.183,跟踪详细路由信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328083910211.png"
                      alt="image-20230328083910211"
                ></p>
<p>9、输入nmap -sV -p139,445 -oG 1.txt 192.168.11.128，其中-sV代表让nmap进行版本侦测，-p代表指定端口，-oG代表输出为1.txt文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328084114117.png"
                      alt="image-20230328084114117"
                ></p>
<p>10、输入. nmap -v -p1-65535 -sV -O -sS -T4 traget 192.168.11.128，用SYN的方法对全端口进行扫描,同时对开放的端口进行端口识别,在insane(5)的时间模板下,探测操作系统的类型,还有显示traceroute的结果,结果输出较为详细</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328084527361.png"
                      alt="image-20230328084527361"
                ></p>
<h4 id="使用综合扫描器扫描网段："><a href="#使用综合扫描器扫描网段：" class="headerlink" title="使用综合扫描器扫描网段："></a>使用综合扫描器扫描网段：</h4><h5 id="x-scan综合扫描工具的使用"><a href="#x-scan综合扫描工具的使用" class="headerlink" title="x-scan综合扫描工具的使用"></a>x-scan综合扫描工具的使用</h5><h5 id="一-实验目的-3"><a href="#一-实验目的-3" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h5><p>1、掌握漏洞扫描工具来发现系统中漏洞，并进行系统加固。 2、掌握漏洞扫描工具来发现系统中漏洞，并进行安全评估。</p>
<h5 id="二-实验原理-3"><a href="#二-实验原理-3" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h5><p>X-SCAN是由安全焦点开发的一个功能强大的扫描工具。采用多线程方式对指定IP地址段(或单机)进行安全漏洞检测，支持插件功能。</p>
<h5 id="三-实验内容-3"><a href="#三-实验内容-3" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h5><p>1、操作x-scan工具。</p>
<h5 id="四-实验环境描述-3"><a href="#四-实验环境描述-3" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h5><p>实验环境 VPC1(虚拟PC） 操作系统类型：windows2003，网络接口：本地连接 VPC1 连接要求 PC 网络接口，本地连接与实验网络直连软件描述 1、学生机要求安装java环境 2、vpc安装windows2003 实验环境描述 1、学生机与实验室网络直连; 2、VPC1与实验室网络直连; 3、学生机与VPC1物理链路连通；</p>
<h5 id="五-实验步骤-3"><a href="#五-实验步骤-3" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h5><p>学生登录实验场景的操作1、 学生单击 “网络拓扑”进入实验场景，单击windows2003中的“打开控制台”按钮，进入虚拟机，我们把windows2003机器作为服务机（自动获取的ip为192.168.100.20）。 2、学生输入账号administrator ,密码123456，登录到实验场景中的目标主机。如图所示:<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328090106129.png"
                      alt="image-20230328090106129"
                >3、 打开d:＼tools＼X-Scan-v3.3-cn＼X-Scan-v3.3,文件，如图所示 :<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328090238963.png"
                      alt="image-20230328090238963"
                >4、关于这些文件的作用可参照x-scan3.3自带的帮助文件，运行x-scan后界面上显示的就是它的帮助，双击xscan_gui.exe 即可运行，界面如下<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328090311564.png"
                      alt="image-20230328090311564"
                >5、标题栏下方为菜单栏，菜单栏下方为一些常用的命令按钮，包括大部分菜单栏中的内容。命令按钮从左到右依次为：扫描参数、开始扫描、暂停扫描、结束扫描、检测报告、使用说明、在线升级、退出。6、x-scan的基本设置点击【扫描参数】按钮，或选择【设置】-&gt;【扫描参数】打开扫描参数对话框，在这里设置x-scan的扫描参数，包括：检测范围、全局设置、插件设置。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328090424398.png"
                      alt="image-20230328090424398"
                >7、检测范围指定ip范围：此处设置x-scan的扫描范围，在【指定ip范围】处填写指定的ip或ip段，可以通过点击右边的【示例】按钮查看有效的ip方式和无效的ip方式。地址薄：在此选择ip地址，在x-scan中提供了地址薄功能，可自行添加ip地址到地址薄中，包括名称、ip和描述。从文件获取主机列表：从指定的文本文件中读取ip地址，注意：件格式应为纯文本，每一行可包含独立ip或域名，也可包含以“-”和“,”分隔的ip范围。</p>
<p>8、全局设置此模块主要用于设置全局性的扫描选项，分为：扫描模块、并发扫描、扫描报告、其它设置。描模块：选择本次扫描需要加载的插件。如果想知道某一插件的具体信息可以选择该插件，在右边会显示对该插件的详细描述，包括版本、作者和描述。可根据需要选择相应的插件。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/bfd0e87a3ef31b231758467543e40c8d.png"
                      alt="图片描述"
                >9、并发扫描：设置并发扫描的主机和并发线程数，也可以单独为每个主机的各个插件设置最大线程数。最大并发主机数量：可以同时检测的主机数量，每扫描一个主机将会启动一个checkhost进程，默认为10。最大并发线程数量：扫描过程中最多可以启动和扫描线程数量，默认为100。各插件最大并发线程数量。用于指定每个模块所用的最大并发线程数，可以通过鼠标定位修改<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328090525827.png"
                      alt="image-20230328090525827"
                >10、扫描报告：扫描结束后生成的报告文件名，保存在log目录下。扫描报告目前支持txt、html和xml三种格式。（报告文件：指定扫描结束后保存的文件名。报告文件类型：选择合适的报告文件格式。保存主机列表：选中此项会将扫描的主机ip保存在一个列表文件中，通过下方列表文件指定，默认提供一个文件名，也可自己指定。扫描完成后自动生成并显示报告：默认选中，如果不选中，在扫描完成后需手工查看）如下图<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/6e024115ab8c9289d63a15a9476efac4.png"
                      alt="图片描述"
                >11、其它设置：用于设置其它杂项。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/087f71cd3634b5f0619d3b39dc5f8e82.png"
                      alt="图片描述"
                >跳过没有响应的主机：若目标主机不响应icmp echo及tcp syn报文，x-scan将跳过对该主机的检测。无条件扫描：如标题所述跳过没有检测到开放端口的主机：若在用户指定的tcp端口范围内没有发现开放端口，将跳过对该主机的后续检测。使用nmap判断远程操作系统：x-scan使用snmp、netbios和nmap综合判断远程操作系统类型，若nmap频繁出错，可关闭该选项。显示详细信息：主要用于调试，平时不推荐使用该选项。12、插件设置该模块包含针对各个插件的单独设置，如“端口扫描”插件的端口范围设置、各弱口令插件的用户名&#x2F;密码字典设置等。端口相关设置：待检测端口：扫描时检测的端口，可添加或删除。检测方式：分为tcp和syn两种方式。tcp方式即tcp的connetc()扫描，与目标主机建立完整的一次tcp连接，完成了tcp的三次握手的全过程。syn为tcp的半开扫描，并不与目标主机建立连接。根据响应识别服务：选中后会根据扫描的端口结果返回相应的服务名，具体的对照在下面“预设知名服务端口”中，可自己添加或删除。snmp相关设置：设置snmp检测的信息。netbios相关设置：选择检测netbios的信息。漏洞检测脚本设置：可以选择相关的漏洞检测脚本，相漏洞脚本以nsl为后缀名。cgi相关设置：设置cgi扫描的相关选项。字典文件设置：在此设置扫描相关密码时对应的字典文件，可自己更改。在扫描参数左侧的最下方有两个按钮：【载入】和【另存】，【载入】用于载入相关的配置文件，【另存】用于将现在设定的配置文件保存。13、使用x-scan对主机进行综合扫描描参数设置完毕后，就可以进行扫描了，点击开始按钮或点击【文件】-&gt;【开始扫描】进行扫描。开始扫描时，x-scan都会先加载漏洞脚本，然后开始扫描。此处以扫描ip为192.168.100.79为例，如下图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/e77740b991b053288320d411110f2dbb.png"
                      alt="图片描述"
                >14、根据设置，点击扫描，扫描完成后会显示html格式的扫描结果，如下图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/c6e2c0f8735fe6c6c2cb128b3cba59bd.png"
                      alt="图片描述"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328091111007.png"
                      alt="image-20230328091111007"
                >15、在x-scan的主界面上有三个选项卡，分别是：普通信息、漏洞信息、错误信息。普通信息：显示x-scan的扫描信息、漏洞信息：显示取得的漏洞信息等。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/e8a8520d4a3499085b0e508a37036259.png"
                      alt="图片描述"
                >16、错误信息：如果扫描过程中出现错误，会在这个选项卡显示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/a4223bb404ef87aef04c2441c2260bd8.png"
                      alt="图片描述"
                >17、当你完成或终止扫描是，会出现以下报告：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/bc77a6d6047ce83a6486a30d783f3573.png"
                      alt="图片描述"
                >普通信息：显示x-scan的扫描信息<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230328090927298.png"
                      alt="image-20230328090927298"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/947e78a1480c62e032ad5ab06a7f4720.png"
                     
                >![图片描述](F:&#x2F;Sc</p>
<p>系统安全 应用系统安全 -》第一章</p>
<h4 id="网安实验二"><a href="#网安实验二" class="headerlink" title="网安实验二"></a>网安实验二</h4><h2 id="木马技术初级实验"><a href="#木马技术初级实验" class="headerlink" title="木马技术初级实验"></a>木马技术初级实验</h2><h5 id="一-实验目的-4"><a href="#一-实验目的-4" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h5><p>了解木马运行和传播方式</p>
<h5 id="二-实验原理-4"><a href="#二-实验原理-4" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h5><p>比起前辈冰河、黑洞来，灰鸽子可以说是国内后门的集大成者。其丰富而强大的功能、灵活多变的操作、良好的隐藏性使其他后门都相形见绌。客户端简易便捷的操作使刚入门的初学者都能充当黑客。当使用在合法情况下时，灰鸽子是一款优秀的远程控制软件。但如果拿它做一些非法的事，灰鸽子就成了很强大的黑客工具。</p>
<h5 id="三-实验内容-4"><a href="#三-实验内容-4" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h5><p>1、灰鸽子木马实验2、了解木马的运行方式和表象</p>
<h5 id="四-实验环境描述-4"><a href="#四-实验环境描述-4" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h5><p>VPC1与VPC2在同一个局域网内。</p>
<h5 id="五-实验步骤-4"><a href="#五-实验步骤-4" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h5><p>1、学生单击“试验环境试验”进入试验场景，打开L5001002win03_001(VPC1)，用户名administrator，密码123456.登录到目标环境<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/50bbffffa0bc319151d5259535c7841b.png"
                      alt="图片描述"
                >2、打开d:tools目录，双击 “黑防灰鸽子2006企业破解版”，进入该目录，双击文件“黑防鸽子2006控制端.exe”，然后点击“接触阻止”如图2所示。灰鸽子控制端界面如图所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/9b2b79163df59e2a803af94e300a9531.png"
                      alt="图片描述"
                >3、在客户端(VPC1)生成服务器端：点击图3菜单栏中的“配置服务程序”，弹出界面，对服务器进行配置。 （1）在“IP通知http访问地址、DNS解析域名或固定IP”一栏填写客户端(VPC1)IP地址，同时可以设置上线图象，上线分组，上线备注，连接密码等内容。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/a073d09b64b27c0647b0045ed7be7196.png"
                      alt="图片描述"
                >（2）选择“安装选项”，“安装路径”的填写如图所示，同时可以选择更改图标等选项。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/f52ee24419c6e2e1c41bf4c26758bcbc.png"
                      alt="图片描述"
                >（3）下面对启动项进行配置，选上“Win2000&#x2F;XP下优先安装成服务启动”；显示名称：可以任意填写（尽量是与系统有关的单词）；服务名称：同上！；描述信息：只要说明此项服务是系统服务，十分重要，不可停止的服务就行！这样配置具有很强的蒙蔽性，可以更好的隐藏自己。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/1f27af8d1fbe9147b13e3a257778e449.png"
                      alt="图片描述"
                >（4）选择“高级选项”，具体配置如图所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/a4a498748f3d3d39d8da38b55ed6cd7c.png"
                      alt="图片描述"
                >（5）解压“插件全集.rar”，可以看到里边包含了很多插件，如图所示。选择“插件功能”，如图所示，可以根据自己的需要添加相应的插件。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/6d5ed6ba3ba4e30d1a4aa50df5d0246e.png"
                      alt="图片描述"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/e2f261a3f53eae6f4fd25021debe8804.png"
                      alt="图片描述"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/aff7e07a1e6f7bc7c5a5b372a9e3a8e2.png"
                      alt="图片描述"
                >（6）配置服务器完成，点击“生成服务器”，提示配置成功。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/e58e378e706b762c3f0af172cba205d7.png"
                      alt="图片描述"
                >4、客户端(VPC1)将配置好的服务器程序（Server.exe）发给服务端(VPC2)（共享文件夹方式传送)</p>
<p>VPC1 的时代IP:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230404082516616.png"
                      alt="image-20230404082516616"
                ></p>
<p>VPC2 的IP：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230404082339626.png"
                      alt="image-20230404082339626"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230404082559903.png"
                      alt="image-20230404082559903"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230411084242171.png"
                      alt="image-20230411084242171"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/4b1e2245586c7210c495f113f39c908d.png"
                      alt="图片描述"
                >5、服务端(VPC2)双击文件“Server.exe”运行。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/981ba8dbb39643b5bc88430b3bafd1f6.png"
                      alt="图片描述"
                >客户端(VPC1)看到服务器(VPC2)（肉鸡）已经上线，如图所示。可以看到服务器端(VPC2)的硬盘分区情况。双击盘符，可以进入对应的硬盘分区，浏览文件，还可以进行删除，上传，下载等操作。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230411083206856.png"
                      alt="image-20230411083206856"
                >6、选择“远程控制命令”，“系统操作”，点击“系统信息”，可以看到如图13所示界面，可以进行的操作有获得“系统信息”，“重启计算机”，“关闭计算机”，“卸载服务端”，如图所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/b1b20907471e60a69534b3980b839cbc.png"
                      alt="图片描述"
                >7、图13中的其他操作还有：剪切板查看、进程管理、服务管理、共享管理、代理服务、插件管理，可以在实验中自己尝试。8、点击菜单栏中的“捕捉屏幕”，可以看到如图14所示窗口，该窗口中显示的就是服务器端(VPC2)的屏幕。单击图14左上角的“传送鼠标和键盘操作”，即可对服务器端(VPC2)进行鼠标和键盘控制，其他如“保存当前画面”，“录制mpeg文件”，“发送组合键”等操作可以自己在实验中尝试。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/4141b56a87421a8b6145463b6194cb90.png"
                      alt="图片描述"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/5952a3c1eed3df6186e1e4d9f8d69d41.png"
                      alt="图片描述"
                >9、灰鸽子除了能够远程视频监控，还有语音监听、语音发送功能，只要远程计算机(VPC2)有摄像头，且正常打开没有被占用，那么你可以看到,远程摄像头捕获的图片！还可以把远程摄像头捕获的画面存为Mpeg格式.远程语音也可以录制成Wav声音文件。点击菜单栏中的“视频语音”，弹出图画面，具体操作自己尝试。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/8371fef9f0a4b430814f11821592d35d.png"
                      alt="图片描述"
                >10、Telnet远程登录，如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/53132bdd5cd684be2ac2d894c2866422.png"
                      alt="图片描述"
                >11、灰鸽子的卸载。方法一：客户端(VPC1)卸载，单击图18中的“卸载服务器”，即可完成对服务器端(VPC2)的卸载。（方法一可不操作，重点考察方法二）<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/1522043a3484578bdae4fb877b6c7a38.png"
                      alt="图片描述"
                >方法二：服务器端(VPC2)手动卸载，这也是实验的重点内容。第一步：找到灰鸽子服务端进程，然后将它终止。由于服务端进程隐藏了（假设我们找不到该程序），所以通过任务管理器是看不到服务端进程的。可以借助工具IceSword（该工具在c:＼tools中）找到隐藏进程，如图19所示。隐藏进程为iexplore.exe，单击右键，结束进程，如图所示。此时可以看到客户端的肉鸡已经下线了，如图所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230411083437443.png"
                      alt="image-20230411083437443"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/c6a7983391e42946cb630afd27f853a7.png"
                      alt="图片描述"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230411083547167.png"
                      alt="image-20230411083547167"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230411083617481.png"
                      alt="image-20230411083617481"
                >第三步：将灰鸽子启动服务删除。首先打开注册表编辑器：“开始-运行-输入regedit”，如图所示。 找到注册表项HKEY_LOCAL_MACHINE＼SYSTEM＼CurrentControlSet＼Services，找到Window xp vista,右键删除，如图24所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/af541edc225359d042f03736474c596d.png"
                      alt="图片描述"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230411083805827.png"
                      alt="image-20230411083805827"
                >第四步：清除灰鸽子文件，在图25中可以看到它的服务启动文件路径为：c:＼Windows＼12345.ini，即配置服务器时，我们在上图中填写的安装路径。下面要做的就是将该文件删除。服务器端进入Windows目录，查找此文件并将它删除。如果没有找到该文件，选择工具－＞文件夹选项，在图26中将“隐藏受保护的操作系统文件”前的对勾去掉，将“隐藏文件和文件夹”中的“显示所有文件和文件夹”选中，此时在windows目录中找到文件12345.ini将它删除。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/db9d3f7f0bec26cf514032b5eb60590d.jpg"
                      alt="图片描述"
                ></p>
<h2 id="DSA签名算法实验"><a href="#DSA签名算法实验" class="headerlink" title="DSA签名算法实验"></a>DSA签名算法实验</h2><h2 id="一-实验目的-5"><a href="#一-实验目的-5" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>通过对数字签名软件的使用，加深对数字签名原理和过程的了解。实验会给出有关数字签名技术的典型协议。结合这些协议充分理解DSA和ECDSA数字签名技术。</p>
<h2 id="二-实验原理-5"><a href="#二-实验原理-5" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>是由发送方利用HASH算法对要发送的信息进行计算得到一个固定的消息摘要值，用发送者的私有密钥加密此消息的HASH值所产生的密文，即数字签名。然后将数字签名和消息一同发给接收方。接收方收到消息和数字签名后，用同样的HASH算法对消息进行计算得到新HASH值，然后用发送者的公开密钥对数字签名解密，将解密后的结果与新HASH值相比较，若相等则说明报文确实来自发送方。</p>
<h2 id="三-实验内容-5"><a href="#三-实验内容-5" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>使用DSAToolv13.exe工具对文件进行加密和解密了解DSA算法的原理</p>
<h2 id="四-实验环境描述-5"><a href="#四-实验环境描述-5" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>Windows 7旗舰版 操作系统DSAToolv13.exe工具</p>
<h2 id="五-实验步骤-5"><a href="#五-实验步骤-5" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、点击开启实验环境，进入实验环境2、在D:＼tools目录下找到DSAToolv13.exe程序，双击运行，运行界面如下：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\4f1194328d4a5cfa42964d52a43daa10.png"
                      alt="图片描述"
                >3、先点击“Start”，在弹出的对话框中选择“是”，并随意在框架内移动鼠标，生成一个随机数种子。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\d90f5daaf7f8fadf15e98179fad100a2.png"
                      alt="图片描述"
                > <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\b289e9fd2df62b00ee76035478bf1a2c.png"
                      alt="图片描述"
                > <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\2b9fc38f0b928b00a5392e74b191c6fb.png"
                      alt="图片描述"
                >4、随机数种子生产完毕后，会在DSAToolv13.exe同目录下产生一个新文件dsaseed.rnd。若之前已经存在此文件则直接点击“Generate”按钮。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\9dd90511fbc2ddb2962944d527d55750.png"
                      alt="图片描述"
                >5、从前面的DSA算法原理可知界面中各项数据的含义。下面点击“Test”，在第一行输入要签名的消息“This is DSA”，单击“Sign”用产生的密钥对消息进行签名。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\de397d4ca9d20307d5ca33820263c246.png"
                      alt="图片描述"
                > 6、单击“Verify”可以对签名进行验证。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\aef11c2ac6165b89985f8fbee4592a77.png"
                      alt="图片描述"
                ></p>
<h2 id="古典密码之仿射密码"><a href="#古典密码之仿射密码" class="headerlink" title="古典密码之仿射密码"></a>古典密码之仿射密码</h2><h2 id="一-实验目的-6"><a href="#一-实验目的-6" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>熟练掌握多表古典密码仿射密码加密算法原理及实现</p>
<h2 id="二-实验原理-6"><a href="#二-实验原理-6" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>基于古典密码中的仿射密码的加解密算法，编写程序进行加解密</p>
<h2 id="三-实验内容-6"><a href="#三-实验内容-6" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>创建一个明文信息，再确定k1，k2，编写实现程序，实现加密和解密操作</p>
<h2 id="四-实验环境描述-6"><a href="#四-实验环境描述-6" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>Windows 7 VC6.0</p>
<h2 id="五-实验步骤-6"><a href="#五-实验步骤-6" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>学生登录实验场景的操作 1、 学生单击 “开始实验”进入实验场景,进入目标主机。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/3c8e5039c6fe6edfd2b294b403d48846.png"
                      alt="图片描述"
                >2.进入windows 7系统。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/b9a5d7b4e374ece0ad163bb25333730d.png"
                      alt="图片描述"
                >3．找到桌面上的Microsoft Visual C++ 6.0，双击打开。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/9880afc8d9f603757ebc7df845f6ab2b.png"
                      alt="图片描述"
                ></p>
<p>4.新建一个C++ Source File，文件名为fangshe。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230411084448771.png"
                      alt="image-20230411084448771"
                >5、将下面的代码输入。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        k = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = k;</span><br><span class="line">    &#125; <span class="keyword">while</span> (k != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Ni</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a * (++i) % b != <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Affine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> length, i = <span class="number">0</span>, ka = <span class="number">0</span>, kb = <span class="number">0</span>;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********仿射密码 * ********n请输入最初的明文: &quot;</span>);</span><br><span class="line">    gets(c);</span><br><span class="line">    length = <span class="built_in">strlen</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入密钥（两数字）:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;ka, &amp;kb);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (gcd(ka, <span class="number">26</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;密钥输入错误，请重新输入&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;％d％d&quot;</span>, &amp;ka, &amp;kb);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt; <span class="number">96</span> &amp;&amp; c[i] &lt; <span class="number">123</span>)</span><br><span class="line">            c[i] = (ka * (c[i] - <span class="number">97</span>) + kb) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i] &gt; <span class="number">64</span> &amp;&amp; c[i] &lt; <span class="number">91</span>)</span><br><span class="line">            c[i] = (ka * (c[i] - <span class="number">65</span>) + kb) % <span class="number">26</span> + <span class="number">65</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n密文为:n％sn&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任何键返回……&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exAffine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> length, i = <span class="number">0</span>, ka = <span class="number">0</span>, kb = <span class="number">0</span>, tmp;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********仿射密码 ********n请输入最初的密文:&quot;</span>);</span><br><span class="line">    gets(c);</span><br><span class="line">    length = <span class="built_in">strlen</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入密钥（两数字）:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;％d％d&quot;</span>, &amp;ka, &amp;kb);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (gcd(ka, <span class="number">26</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;密钥输入错误，请重新输入&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;％d％d&quot;</span>, &amp;ka, &amp;kb);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt; <span class="number">64</span> &amp;&amp; c[i] &lt; <span class="number">91</span>) &#123;</span><br><span class="line">            tmp = Ni(ka, <span class="number">26</span>) * ((c[i] - <span class="number">65</span>) - kb);</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>)</span><br><span class="line">                c[i] = tmp % <span class="number">26</span> + <span class="number">26</span> + <span class="number">65</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                c[i] = tmp % <span class="number">26</span> + <span class="number">65</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[i]&gt; <span class="number">96</span> &amp;&amp; c[i] &lt; <span class="number">123</span>) &#123;</span><br><span class="line">            tmp = Ni(ka, <span class="number">26</span>) * ((c[i] - <span class="number">97</span>) - kb);</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>)</span><br><span class="line">                c[i] = tmp % <span class="number">26</span> + <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                c[i] = tmp % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n明文为:n％sn&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任何键返回……&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> i = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\\n&quot;</span>, <span class="string">&quot;********请按1~3选择:*******&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\\n&quot;</span>, <span class="string">&quot;1.仿射加密/n2.仿射解密/n3.退出/n&quot;</span>);</span><br><span class="line">    i = getchar();</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="string">&#x27;3&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            Affine();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">            exAffine();</span><br><span class="line">        i = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/9bfd9a7dcb066e74c41b5b8cee53a890.png"
                      alt="图片描述"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/bced1529ee711261404ce7a88dd52888.png"
                      alt="图片描述"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/989d551d84f009d589b535db039a76a2.png"
                      alt="图片描述"
                >6、输入想要加密的文字与密钥获取密文，并且小写加密为小写，大写加密为大写。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/8766647cde53b78e56fdc78846efcdb1.png"
                      alt="图片描述"
                >7、再进入解密模式输入密文与密钥获得明文，并且小写解密为小写，大写解密为大写。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/c8b2841aaeca8246f983b897e1f91426.png"
                      alt="图片描述"
                >8、实验结束，关闭实验场景。</p>
<h4 id="网安实验四："><a href="#网安实验四：" class="headerlink" title="网安实验四："></a>网安实验四：</h4><h2 id="对称密码-DES实验"><a href="#对称密码-DES实验" class="headerlink" title="对称密码-DES实验"></a>对称密码-DES实验</h2><h2 id="一-实验目的-7"><a href="#一-实验目的-7" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>通过用DES算法对实际的数据进行加密和解密来深刻了解DES的运行原理。</p>
<h2 id="二-实验原理-7"><a href="#二-实验原理-7" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>DES的加解密相关原理</p>
<h2 id="三-实验内容-7"><a href="#三-实验内容-7" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>编程实现DES的加解密流程</p>
<h2 id="四-实验环境描述-7"><a href="#四-实验环境描述-7" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>一台安装windows7、VC6.0计算机。</p>
<h2 id="五-实验步骤-7"><a href="#五-实验步骤-7" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、学生单击“开始试验”进入试验场景。2.桌面找到Visual C++ 6.0双击打开<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\dbcd8e4d9e42c3aaf0beda1d868f7ff8.png"
                      alt="图片描述"
                >3.点击“文件”——“新建”<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\d5760fce209873ac9a066fbb845b13ea.png"
                      alt="图片描述"
                >4.创建一个win32控制台工程，工程名称和位置自定。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230411080251202.png"
                      alt="image-20230411080251202"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\c982a1eef6cfa7890968a86060102ac9.png"
                      alt="图片描述"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418081950081.png"
                     
                >5.左侧工作区，选择“FileView”选项卡。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\65fb8aa1e85fc5ecedd162c998df4feb.png"
                      alt="图片描述"
                >6.右键工程文件名称，选择“添加文件到工程”。可到c:<code>＼</code>Tools<code>＼</code>51elab1007Bdes中找到相关代码（G_des.c，test.cpp，des.h）。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418082513985.png"
                      alt="image-20230418082513985"
                >![图片描述]<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418082606883.png"
                      alt="image-20230418082606883"
                >7.根据原理编写程序，并编译运行（依次点击下图左起三个显性按钮进行编译、建立、运行）。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\ff2a9423116112ae063934a09bd1df99.png"
                      alt="图片描述"
                >8、依次按要求hello、hh、回车，对实验进行验证，并得出结果如下图所示；<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418082419409-16835631851851.png"
                      alt="image-20230418082419409"
                >9.实验至此结束，关闭实验场景。</p>
<h2 id="实验五：非对称密码-RSA实验"><a href="#实验五：非对称密码-RSA实验" class="headerlink" title="实验五：非对称密码-RSA实验"></a>实验五：非对称密码-RSA实验</h2><h2 id="一-实验目的-8"><a href="#一-实验目的-8" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>学生通过实验能深入、透彻地理解RSA算法的基本原理；能使用RSA对文件进行加密。</p>
<h2 id="二-实验原理-8"><a href="#二-实验原理-8" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>对称密码算法要求通信双方通过交换密钥实现使用同一个密钥，这在密钥管理、发布和安全性方面存在很多问题，而非对称密码算法解决了这个问题。</p>
<p>非对称密码算法是指一个加密系统的加密密钥和解密密钥是不相同，或者说不能从其中一个推导出另一个。在非对称密码算法的两个密钥中，一个是用于加密的密钥，它是可以公开的称为公钥；另一个是用于解密的密钥，是保密的，称为私钥。非对称密码算法解决了对称密码体制中密钥管理的难题，并提供了对信息发送人的身份进行验证的手段，是现代密码学的最重要的发明和进展。</p>
<p>RSA密码体制是目前为止最为成功的非对称密码算法，是在1977年由Rivest、Shamir和Adleman提出的第一个比较完善的非对称密码算法。它的安全性是建立在“大数分解和素性检测”这个数论难题的基础上，即将两个大素数相乘在计算上容易实现，而将该乘积分解为两个大素数因子的计算量相当大。虽然的安全性还未能得到理论证明，但经过20多年的密码分析和攻击，迄今仍然被实践证明是安全的。</p>
<p>RSA算法描述如下：</p>
<p>1．公钥</p>
<p>选择两个互异的大素数p和q，n是二者的乘积，即n &#x3D; pq，使Φ(n)＝（p-1）(q-1)，Φ(n)为欧拉函数。随机选取正整数e，使其满足gcd (e， Φ(n))&#x3D;1，即e和Φ(n)互质，则将(n，e)作为公钥。</p>
<p>2．私钥</p>
<p>求出正数d，使其满足e×d&#x3D;1 modΦ(n)，则将(n，d)作为私钥。</p>
<p>3．加密算法</p>
<p>对于明文M，由C&#x3D;Me mod n ，得到密文C。</p>
<p>4．解密算法</p>
<p>对于密文C，由M&#x3D;Cd mod n，得到明文M。</p>
<p>如果窃密者获得了n，e和密文C，为了破解密文他必须计算出私钥d，为此需要先分解n为p和q。为了提高破解难度，达到更高的安全性，一般商业应用要求n的长度不小于1024bit，更重要的场合不小于2048bit。</p>
<h2 id="三-实验内容-8"><a href="#三-实验内容-8" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>1.学生通过实验能深入、透彻地理解RSA算法的基本原理</p>
<p>2.能使用RSA对文件进行加密；</p>
<p>3.根据给出的RSA算法简单实现的C代码源程序。</p>
<h2 id="四-实验环境描述-8"><a href="#四-实验环境描述-8" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>运行windows或linux操作系统的PC机，具有gcc（linux）、VC（windows）等C语言编译环境</p>
<h2 id="五-实验步骤-8"><a href="#五-实验步骤-8" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、学生单击“开始试验”进入试验场景。2.点击进入目标主机上的目录“C:<code>＼</code>tools<code>＼</code>51elab1022B”。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\97864d437e7d063629aa60f2c79079ee.png"
                      alt="图片描述"
                >3.点击打开“RSATool”，出现如下界面。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418083041080.png"
                     
                >4.单击“Start”按钮，然后随意移动鼠标直到提示信息框出现，以获取一个随机数种子</p>
<p>5.在“Keysize”中输入你想要的密钥的长度，从32到4096，位数越多安全性也高，但运算速度越慢，一般选择1024位足够了，单击“Generate”按钮生成。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418083312353.png"
                      alt="image-20230418083312353"
                ></p>
<p>生成密钥：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418083353570.png"
                      alt="image-20230418083353570"
                ></p>
<p>6.单击“Test”按钮测试，在“Message to encrypt”编辑框中随意输入一段文本，然后单击“Encrypt”按钮加密，再单击“Decrypt”按钮解密，看解密后的结果是否和所输入的一致，如果一致表示所生成的RSA密钥可用，否则需要重新生成，如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418083426722.png"
                      alt="image-20230418083426722"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418083455249.png"
                      alt="image-20230418083455249"
                ></p>
<h5 id="实验六："><a href="#实验六：" class="headerlink" title="实验六："></a>实验六：</h5><h2 id="Hash算法之MD5"><a href="#Hash算法之MD5" class="headerlink" title="Hash算法之MD5"></a>Hash算法之MD5</h2><h2 id="一-实验目的-9"><a href="#一-实验目的-9" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>认识理解数据哈希算法，了解其基本原理，掌握MD5算法过程。</p>
<h2 id="二-实验原理-9"><a href="#二-实验原理-9" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>MD5算法实现如下:</p>
<p>(1)MD5算法是对输入的数据进行补位，使得如果数据位长度LEN对512求余的结果是448。</p>
<p>(2)补数据长度。</p>
<p>(3)初始化MD5参数。</p>
<p>(4)处理位操作函数。</p>
<p>(5)主要变换。</p>
<p>(6)输出结果。</p>
<h2 id="三-实验内容-9"><a href="#三-实验内容-9" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>1、学生通过实验能深入、透彻地理解MD5算法的基本原理</p>
<p>2、能使用MD5对一段信息产生信息摘要；3、根据给出的MD5算法简单实现的C代码源程序。</p>
<h2 id="四-实验环境描述-9"><a href="#四-实验环境描述-9" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>Windows7操作系统Visual C++ 6.0相关代码</p>
<h2 id="五-实验步骤-9"><a href="#五-实验步骤-9" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、学生单击“开始试验”进入试验场景。2.桌面找到Visual C++ 6.0双击。选择“文件”“新建”。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\dd3e61e97450cc5ac28d19b920de4cf1.png"
                      alt="图片描述"
                >3.创建一个win32控制台工程，工程名称和位置自定（此处工程名称以“HELLO”为例）。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418083805800.png"
                      alt="image-20230418083805800"
                >4.左侧工作区，选择“FileView”选项卡。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418083926204.png"
                      alt="image-20230418083926204"
                >5.右键工程文件名称，选择“添加文件到工程”。可到C:<code>＼</code>TOOLS<code>＼</code>51elab1009B中找到相关代码。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418083852761.png"
                      alt="image-20230418083852761"
                >双击“MD5.cpp”文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418084017241.png"
                      alt="图片描述"
                >6.根据实验原理编写程序，编译并运行，输入要进行MD5加密的数字<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418084051426.png"
                      alt="image-20230418084051426"
                >运行结果如下：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418084218076.png"
                      alt="image-20230418084218076"
                >9.至此实验结束，关闭虚拟机。</p>
<h2 id="数字签名之RSA"><a href="#数字签名之RSA" class="headerlink" title="数字签名之RSA"></a>数字签名之RSA</h2><h2 id="一-实验目的-10"><a href="#一-实验目的-10" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>通过实验实例了解RSA算法数字签名。</p>
<h2 id="二-实验原理-10"><a href="#二-实验原理-10" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>RSA数字签名体制的基本算法表述：</p>
<p>(1)体制参数　　</p>
<p>假设用户甲使用如下的参数:　　</p>
<p>大合数n&#x3D;p1*p2，其中p1和p2是大素数；　　</p>
<p>用户甲将公开模数n和公钥e，而将p1，p2与私钥d严格保密。</p>
<p>(2)签名算法　　</p>
<p>假设用户甲对数据M∈Zn进行签名，计算　　</p>
<p>S&#x3D;Sig(M)&#x3D;Md mod n 并将S作为用户甲对数据M的数字签名附在数据M后。</p>
<p>(3)验证算法　　</p>
<p>假设用户乙需要验证用户甲对数据M的签名S，用户乙计算M’&#x3D;Sdmod n并判断 M’是否等于M，如果M’&#x3D;M，则说明签名S确实是用户甲所产生的，否则，签名S可能是由攻击者伪造生成的。完整地，验证算法可以表述如下：Ver(M,S)&#x3D;(M&#x3D;Sd mod n) true:false　　</p>
<p>如果(M&#x3D;Sd mod n )为真，则表达式的值为true，否则表达式的值为false。</p>
<p>(4)实现过程</p>
<p><code>RSA数字签名体制的实现过程如图1所示。发送方用户甲发送报文M时，先用自己的私钥d1对报文进行加密，产生密文d1(M)；再用接收方用户乙的公钥e2进行第二次加密，产生密文e2(d1(M))。接收方用户乙收到密文后，先用自己的私钥d2进行第一次解密，还原出密文d1(M)，即d2(e2(d1(M)))=d1(M)；再用发送方用户甲的公钥e1进行第二次解密，得到明文P，即e1(d1(M))=M。      RSA数字签名体制必须同时使用收。发双方的私钥d1和公钥e1才能获得原文(明文)，也才能完成发送方的身份认证和接收方无法伪造或篡改报文的功能。因为只有发送方才有其私钥d1，所以，只要能用其公钥e1还原，发送方就无法否认所发送的报文。 </code></p>
<h2 id="三-实验内容-10"><a href="#三-实验内容-10" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>了解RSA算法数字签名。</p>
<h2 id="四-实验环境描述-10"><a href="#四-实验环境描述-10" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>Windows7操作系统RSA.exe应用程序</p>
<h2 id="五-实验步骤-10"><a href="#五-实验步骤-10" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、学生单击“开始试验”进入试验场景。</p>
<p>2.在c:<code>＼</code>tools<code>＼</code>51elab1012B下找到RSA应用程序RSA.exe双击打开，运行界面如下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418084534890.png"
                      alt="image-20230418084534890"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418084551917.png"
                      alt="image-20230418084551917"
                >3.单击下方“产生密钥”就可以随机产生1024位的密钥，产生p、q、n、e、d，同时把明文数字化。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418084730835.png"
                      alt="image-20230418084730835"
                >4.单击“加密”，便可得到加密后的密文。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418084829472.png"
                      alt="image-20230418084829472"
                >5.单击“解密”，得到解密后的明文，包括十六进制明文和字符明文。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230418084846510.png"
                      alt="image-20230418084846510"
                >6.至此实验结束，根据RSA签名原理可查看部分源代码，对RSA签名有更加深入的了解。</p>
<p>关闭虚拟机结束实验。</p>
<p>实验七：</p>
<h2 id="linux基本应用-文件权限管理"><a href="#linux基本应用-文件权限管理" class="headerlink" title="linux基本应用-文件权限管理"></a>linux基本应用-文件权限管理</h2><h2 id="一-实验目的-11"><a href="#一-实验目的-11" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>1、了解使用chmod按照要求更改用户对于特定文件的权限 </p>
<p>2、使用unmask命令更改默认权限 </p>
<p>3、使用chown命令更改文件的属主、属组</p>
<h2 id="二-实验原理-11"><a href="#二-实验原理-11" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>文件是操作系统用来存储信息的基本结构，是一组信息的集合，文件通过文件名来唯一的标识。linux中的文件名称最长可允许255个字符，这些字符可用A<del>Z、0</del>9、.、_、-等符号来表示。</p>
<h2 id="三-实验内容-11"><a href="#三-实验内容-11" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、了解使用chmod按照要求更改用户对于特定文件的权限  2、使用unmask命令更改默认权限 3、使用chown命令更改文件的属主、属组 </span><br></pre></td></tr></table></figure></div>

<h2 id="四-实验环境描述-11"><a href="#四-实验环境描述-11" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验环境 VPC1(虚拟PC） 操作系统类型：linux，网络接口：eth0 VPC1 连接要求 PC 网络接口，本地连接与实验网络直连软件描述 1、学生机要求安装java环境 2、vpc安装linux 实验环境描述 （1）学生机与实验室网络直连; （2）VPC1与实验室网络直连; （3）学生机与VPC1物理链路连通； </span><br></pre></td></tr></table></figure></div>

<h2 id="五-实验步骤-11"><a href="#五-实验步骤-11" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、学生单击实验拓扑按钮，进入实验场景，单击“打开控制台”按钮，进入目标主机。</p>
<p>2、学生输入账号root,密码123456，登录到实验场景中的目标主机。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418085134518.png"
                      alt="image-20230418085134518"
                >3、在test的家目录建立一个user文件夹。cd &#x2F;home&#x2F;test；mkdir user。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418085225027.png"
                      alt="image-20230418085225027"
                >4、 在user文件夹下建立一个file文件。cd user；touch file。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418085305529.png"
                      alt="image-20230418085305529"
                >5、 查看file文件的所有属性。ls –l。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418085324053.png"
                      alt="image-20230418085324053"
                >6、 对文件file设置权限，使其他用户可以对此文件进行写操作。并查看设置结果。chmod o+w file。如图所示：　　　　　　　　　 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418085409748.png"
                      alt="image-20230418085409748"
                >7、 取消同组用户对此文件的读取权限。查看设置结果。chmod g-r file。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418085525743.png"
                      alt="image-20230418085525743"
                >8、 用数字形式为文件file设置权限，所有者可读、可写、可执行；其他用户和所属组用户只有读和执行的权限。设置完成后查看设置结果。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\69fa78146e0b60304aa419a4ce6bfbb5.png"
                      alt="图片描述"
                >9、 用数字形式更改文件file的权限，使所有者只能读取此文件，其他任何用户都没有权限。查看设置结果。chmod 400 file。如图所示： 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418085700010.png"
                      alt="image-20230418085700010"
                >10、改变文件的所有者，查看目录test及其中文件的所属用户和组，修改file文件的所有者为test。chown test.test file。如图所示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418085742806.png"
                      alt="image-20230418085742806"
                >11、实验结束。</p>
<h2 id="Linux文件系统管理"><a href="#Linux文件系统管理" class="headerlink" title="Linux文件系统管理"></a>Linux文件系统管理</h2><h2 id="一-实验目的-12"><a href="#一-实验目的-12" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>熟悉Linux系统环境下文件管理相关操作命令掌握Linux操作系统中文件管理相关的安全配置方法</p>
<h2 id="二-实验原理-12"><a href="#二-实验原理-12" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>Linux文件系统的安全主要是通过设置文件的权限来实现的。每一个Linux的文件或目录都有3组属性，分别定义文件或目录的所有者、用户组号、其它人的使用权限</p>
<h2 id="三-实验内容-12"><a href="#三-实验内容-12" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>通过chown命令修改文件所有权；去掉文件的SUID和SGID属性；通过chattr命令修改文件系统属性</p>
<h2 id="四-实验环境描述-12"><a href="#四-实验环境描述-12" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>Linux实验台</p>
<h2 id="五-实验步骤-12"><a href="#五-实验步骤-12" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>运行Linux实验台Linux_1,用户名：root，密码：123456。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509081131614.png"
                      alt="image-20230509081131614"
                >一、修改文件所有权 (1)查看当前文件属性：当前目录是&#x2F;root，使用ls –l查看发现时空文件夹。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/10c2e7529b7d5cdecc80dcc826363342.png"
                      alt="图片描述"
                >现复制根目录下bin文件夹中的文件到root文件夹以便进行实验。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509081606857.png"
                      alt="image-20230509081606857"
                >进入root下的bin文件夹，使用ls–l|more（字母l）命令查看bin中文件的详细信息：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509081845795.png"
                      alt="image-20230509081845795"
                > <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/59bf1c720a686916c9a8496c2c06661c.png"
                      alt="图片描述"
                >2) 修改root&#x2F;bin目录下文件权限，将bin文件的所有者由root改为daemon：chown daemon *<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/78769bfa32b2fd6807546b60f3091ea8.png"
                      alt="图片描述"
                >(3)查看修改后的文件属性：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509082046116.png"
                      alt="image-20230509082046116"
                >恢复目录下文件权限：chown root *<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/28c187f19f66b60a25d11a6226dbe3b1.png"
                      alt="图片描述"
                >二、修改主目录文件权限 (1)查看当前文件属性，第一列为用户root的权限：ls–l<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509081845795.png"
                      alt="image-20230509081845795"
                >(2)修改主目录下文件权限：chmod 700 *，700表示文件所以者可读、写、运行，而其他人不可读、写、运行的模式；<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/89a0792eb0d29e029085110d53ae9889.png"
                      alt="图片描述"
                >3)查看修改后的文件属性，注意第一列显示的用户权限的变化：ls –l![图片描述]<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509082224196.png"
                      alt="image-20230509082224196"
                >三、修改系统文件的SUID和SGID的权限 (1)查看当前文件夹&#x2F;root&#x2F;bin中bash文件的属性：ls –l bash<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509082301781.png"
                      alt="image-20230509082301781"
                >(2)修改主目录下文件权限：chmod 777 bash<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509082352776.png"
                      alt="图片描述"
                >查看修改后的文件属性：ls –l bash![图片描述]<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230509082413320.png"
                      alt="image-20230509082413320"
                ></p>
<p>实验八：</p>
<h2 id="iptables简介"><a href="#iptables简介" class="headerlink" title="iptables简介"></a>iptables简介</h2><h2 id="一-实验目的-13"><a href="#一-实验目的-13" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>了解iptables的使用原理</p>
<h2 id="二-实验原理-13"><a href="#二-实验原理-13" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>Linux使用一个信息包过滤系统来实现防火墙的功能， 即Iptables&#x2F;Netfilter过滤系统。 　　</p>
<p>Iptables和Netfilter是Linux防火墙过滤系统分别在用户态和内核态的表现形式。</p>
<p>Iptables： Linux防火墙的“用户态”， 用户管理防火墙的命令工具。　　</p>
<p>Netfilter： Linux防火墙的“内核态” ，内核中的包过滤防火墙功能体系　</p>
<p>Iptables功能强大、可以用于对防火墙规则的增、删、改、查。防火墙规则是以表的形式存储的， 而这些表集成在内核中。</p>
<h2 id="三-实验内容-13"><a href="#三-实验内容-13" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>对iptables作一个简单的介绍</p>
<h2 id="四-实验环境描述-13"><a href="#四-实验环境描述-13" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC机：Redhat5.1.19.6 账号密码:root/123456 </span><br></pre></td></tr></table></figure></div>

<h2 id="五-实验步骤-13"><a href="#五-实验步骤-13" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>iptables防火墙可以用于创建过滤(filter)与NAT规则。</p>
<p>所有Linux发行版都能使用iptables，因此理解如何配置 iptables将会帮助你更有效地管理Linux防火墙。如果你是第一次接触iptables，你会觉得它很复杂，但是一旦你理解iptables的工 作原理，你会发现其实它很简单。</p>
<p>首先介绍iptables的结构：iptables -&gt; Tables -&gt; Chains -&gt; Rules. 简单地讲，tables由chains组成，而chains又由rules组成。</p>
<p>一、iptables的表与链</p>
<p>iptables具有Filter, NAT, Mangle, Raw四种内建表：</p>
<p><strong>1. Filter表</strong></p>
<p>Filter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：</p>
<p><strong>INPUT链</strong> – 处理来自外部的数据。</p>
<p><strong>OUTPUT链</strong> – 处理向外发送的数据。</p>
<p><strong>FORWARD链</strong> – 将数据转发到本机的其他网卡设备上。</p>
<p><strong>2. NAT表</strong>NAT表有三种内建链：</p>
<p><strong>PREROUTING链</strong> – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。</p>
<p><strong>POSTROUTING链</strong> – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。</p>
<p><strong>OUTPUT链</strong> – 处理本机产生的数据包。</p>
<p><strong>3. Mangle表</strong></p>
<p>Mangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链：PREROUTINGOUTPUTFORWARDINPUTPOSTROUTING</p>
<p><strong>4. Raw表</strong>Raw表用于处理异常，它具有2个内建链：PREROUTING chainOUTPUT chain</p>
<p><strong>二、IPTABLES 规则(Rules)</strong> </p>
<p>牢记以下三点式理解iptables规则的关键：Rules包括一个条件和一个目标(target)如果满足条件，就执行目标(target)中的规则或者特定值。如果不满足条件，就判断下一条Rules。</p>
<p><strong>目标值（Target Values）</strong>下面是你可以在target里指定的特殊值：</p>
<p><strong>ACCEPT</strong> – 允许防火墙接收数据包<strong>ｄｒｏｐ</strong>(大写) – 防火墙丢弃包</p>
<p><strong>QUEUE</strong> – 防火墙将数据包移交到用户空间</p>
<p><strong>RETURN</strong> – 防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain)中。</p>
<p><strong>三、iptables传输数据包的过程</strong></p>
<p>① 当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去。</p>
<p>② 如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。</p>
<p>③ 如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。</p>
<p><strong>四、规则表之间的优先顺序：</strong></p>
<p>Raw &gt; mangle &gt; nat &gt; filter规则链之间的优先顺序（分三种情况）：</p>
<p><strong>第一种情况：入站数据流向</strong><code>从外界到达防火墙的数据包，先被PREROUTING规则链处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发往何处），如果数据包的目标主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给INPUT链进行处理（决定是否允许通过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。 </code></p>
<p><strong>第二冲情况：转发数据流向</strong><code>来自外界的数据包到达防火墙后，首先被PREROUTING规则链处理，之后会进行路由选择，如果数据包的目标地址是其它外部地址（比如局域网用户通过网关访问QQ站点的数据包），则内核将其传递给FORWARD链进行处理（是否转发或拦截），然后再交给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</code></p>
<p><strong>第三种情况：出站数据流向</strong><code> 防火墙本机向外部地址发送的数据包（比如在防火墙主机中测试公网DNS服务器时），首先被OUTPUT规则链处理，之后进行路由选择，然后传递给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</code> </p>
<p><strong>五、规则的写法</strong></p>
<p>iptables定义规则的方式比较复杂:</p>
<p><code>格式：iptables [-t table] COMMAND chain CRETIRIA -j ACTION    </code> </p>
<p> <code>-t table ：3个filter nat mangle      </code></p>
<p> <code>COMMAND：定义如何对规则进行管理     </code></p>
<p> <code>chain：指定你接下来的规则到底是在哪个链上操作的，当定义策略的时候，是可以省略的      CRETIRIA:指定匹配标准     </code> </p>
<p> <code>-j ACTION :指定如何进行处理  比如：不允许172.16.0.0/24的进行访问。  </code></p>
<p> <code>iptables -t filter -A INPUT -s 172.16.0.0/16 -p udp --dport 53 -j ｄｒｏｐ（注：大写ｄｒｏｐ）  </code></p>
<p> <code>当然你如果想拒绝的更彻底：  </code></p>
<p> <code>iptables -t filter -R INPUT 1 -s 172.16.0.0/16 -p udp --dport 53 -j REJECT  iptables -L -n -v   `` #查看定义规则的详细信息 </code></p>
<h2 id="iptables对IP的管理"><a href="#iptables对IP的管理" class="headerlink" title="iptables对IP的管理"></a>iptables对IP的管理</h2><h2 id="一-实验目的-14"><a href="#一-实验目的-14" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>添加简单的规则实现对ip的管理</p>
<h2 id="二-实验原理-14"><a href="#二-实验原理-14" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>iptables中的filter表作包过滤</p>
<h2 id="三-实验内容-14"><a href="#三-实验内容-14" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>两台虚拟机，通过在一台虚拟机上添加iptables规则，实现虚拟机之间在添加规则前后能否ping通。</p>
<h2 id="四-实验环境描述-14"><a href="#四-实验环境描述-14" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>2台Redhat的虚拟机Redhat01 IP: 172.16.1.101 用户名：root 密码：123456Redhat02 IP: 172.16.1.102 用户名：root 密码：123456</p>
<h2 id="五-实验步骤-14"><a href="#五-实验步骤-14" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、在Redhat01上使用 ifconfig eth0 172.16.1.101 netmask 255.255.255.0 命令修改ip</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418091258656.png"
                      alt="image-20230418091258656"
                >2、在Redhat02上使用 ifconfig eth0 172.16.1.102 netmask 255.255.255.0 命令修改ip</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418091109550.png"
                      alt="image-20230418091109550"
                ></p>
<p>3、首先先查看在没有添加任何规则的时候，<strong>Redhat01</strong>能否ping通<strong>Redhat02</strong>虚拟机。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418091332767.png"
                      alt="image-20230418091332767"
                >4、然后在<strong>redhat02</strong>这台虚拟机上添加以下规则并查看规则是否已添加上：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418091627954.png"
                      alt="image-20230418091627954"
                ></p>
<p>5、最后再使用<strong>Redhat01</strong>虚拟机去ping <strong>Redhat02</strong>看是否能ping通<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:\ScreenShotTools\images\image-20230418091706397.png"
                      alt="image-20230418091706397"
                >ping不通说明我们添加的规则已经生效了。</p>
<p>6、实验结束，关闭虚拟机。</p>
<h2 id="iptables对端口的管理"><a href="#iptables对端口的管理" class="headerlink" title="iptables对端口的管理"></a>iptables对端口的管理</h2><h2 id="一-实验目的-15"><a href="#一-实验目的-15" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>添加简单的规则实现对端口的管理</p>
<h2 id="二-实验原理-15"><a href="#二-实验原理-15" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>两台虚拟机，通过在一台虚拟机上添加iptables规则，实现虚拟机之间在添加规则前后能否使用ssh连上。</p>
<h2 id="三-实验内容-15"><a href="#三-实验内容-15" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>对22号端口进行开关闭实验</p>
<h2 id="四-实验环境描述-15"><a href="#四-实验环境描述-15" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>2台Redhat5.1.19.6的虚拟机Redhat01 IP: 172.16.1.101 用户名：root 密码：123456Redhat02 IP: 172.16.1.102 用户名：root 密码：123456</p>
<h2 id="五-实验步骤-15"><a href="#五-实验步骤-15" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>默认情况下ssh 是使用22端口的，所以我们有以下步骤：1、在Redhat01上使用 ifconfig eth0 172.16.1.101 netmask 255.255.255.0 命令修改ip2、在Redhat02上使用 ifconfig eth0 172.16.1.102 netmask 255.255.255.0 命令修改ip3、在<strong>Redhat01</strong>上使用ssh连接<strong>Redhat02</strong>虚拟机：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/e46559cd3596a01b59d5fea86eb7f9c1.png"
                      alt="图片描述"
                >发现我们是可以连接上的4、然后我们在<strong>Redhat02</strong>这个虚拟机上添加以下规则：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/8bdc14fb3c26169c99d66bf6b1c5434f.png"
                      alt="图片描述"
                >5、最后在<strong>Redhat01</strong>上连接<strong>Redhat02</strong>，发现无法连接，说明我们添加的规则已经生效了。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/db329396669a598d979c0352e05f2721.png"
                      alt="图片描述"
                >6、实验结束，关闭虚拟机</p>
<h2 id="iptables对协议的管理"><a href="#iptables对协议的管理" class="headerlink" title="iptables对协议的管理"></a>iptables对协议的管理</h2><h2 id="一-实验目的-16"><a href="#一-实验目的-16" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>通过添加iptables规则，实现对tcp、udp、icmp协议的管理</p>
<h2 id="二-实验原理-16"><a href="#二-实验原理-16" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>iptables的策略防火墙的3个表：1.filter 定义允许或者不允许的2.nat 定义地址转换的3.mangle功能:修改报文原数据对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING注意：规则的次序非常关键，谁的规则越严格，应该放的越靠前，而检查规则的时候，是按照从上往下的方式进行检查的。</p>
<h2 id="三-实验内容-16"><a href="#三-实验内容-16" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>两台虚拟机，通过在一台虚拟机上添加iptables规则，实现虚拟机之间在添加规则前后能否ping通。</p>
<h2 id="四-实验环境描述-16"><a href="#四-实验环境描述-16" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>2台redhat的虚拟机Redhat01 IP: 172.16.1.223 用户名：root 密码：123456Redhat02 IP: 172.16.1.224 用户名：root 密码：123456</p>
<h2 id="五-实验步骤-16"><a href="#五-实验步骤-16" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、登录虚拟机Redhat01修改ip<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/063af23177e973823fee0b2c887117db.png"
                      alt="图片描述"
                >登录虚拟机Redhat02修改ip<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/55d49537b653b3dd1470325d4a8dfd91.png"
                      alt="图片描述"
                >2、默认情况下icmp是开放的，在Redhat01上所以我们有以下步骤：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/8fc993eb6eae05b5b7207ab1fc5ef3f4.png"
                      alt="图片描述"
                >发现我们是可以ping通的3、然后我们在<strong>Redhat02</strong>这个虚拟机上添加以下规则并查看：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/ccac60ea4153ac975ab9ccbc63653b29.png"
                      alt="图片描述"
                >4、最后在Redhat01上去ping Redhat02，发现无法ping通，说明我们添加的规则已经生效了。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/5fd6939977d23fa61f870a0fc330b558.png"
                      alt="图片描述"
                >5、实验结束，关闭虚拟机</p>
<h2 id="iptables抵御轻量级Ddos攻击"><a href="#iptables抵御轻量级Ddos攻击" class="headerlink" title="iptables抵御轻量级Ddos攻击"></a>iptables抵御轻量级Ddos攻击</h2><h2 id="一-实验目的-17"><a href="#一-实验目的-17" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>通过添加iptables规则，实现简单的ddos防御</p>
<h2 id="二-实验原理-17"><a href="#二-实验原理-17" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>DDOS deflate是一个轻量级的脚本,以协助阻止拒绝服务攻击的过程中的BASH shell 脚本</p>
<h2 id="三-实验内容-17"><a href="#三-实验内容-17" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>通过添加iptables规则，实现简单的ddos防御</p>
<h2 id="四-实验环境描述-17"><a href="#四-实验环境描述-17" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>2台redhat的虚拟机redhatIP: 172.16.1.25redhatIP: 172.16.1.26</p>
<h2 id="五-实验步骤-17"><a href="#五-实验步骤-17" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>输入用户名：root 密码：123456</p>
<p>1、在Redhat01上使用 ifconfig eth0 172.16.1.25 netmask 255.255.255.0 命令修改ip</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425080436843.png"
                      alt="image-20230425080436843"
                ></p>
<p>2、在Redhat02上使用 ifconfig eth0 172.16.1.26 netmask 255.255.255.0 命令修改ip</p>
<p>在Redhat02虚拟机<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425080610089.png"
                      alt="image-20230425080610089"
                >上添加规则设置为：前5个包正常通过，后续的包每1分钟通过6个，即每10秒钟通过1个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT  -p icmp  -m limit --limit 6/m --limit-burst 5 -j ACCEPT</span><br></pre></td></tr></table></figure></div>

<p>设置默认策略为丢包，否则前面设置无效</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT ｄｒｏｐ（注ｄｒｏｐ大写）</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425080818368.png"
                      alt="image-20230425080818368"
                ></p>
<p>然后在Redhat01节点使用ping命令来ping Redhat02节点，会发现ping前5次是正常的，后面会每过10秒再ping一个包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425080932506.png"
                      alt="image-20230425080932506"
                ></p>
<p>(补充)抵御DOS：可以允许外网网卡每个IP最多15个初始连接,超过的丢弃</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth1(外网网卡) -p tcp --syn -m connlimit --connlimit-above 15 -j ｄｒｏｐ（注ｄｒｏｐ小写） ``iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure></div>



<p>防止SYN攻击 轻量级预防&#96;</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -N syn-flood</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p tcp --syn -j syn-flood</span><br><span class="line"></span><br><span class="line">iptables -I syn-flood -p tcp -m limit --limit 3/s --limit-burst 6 -j RETURN</span><br><span class="line"></span><br><span class="line">iptables -A syn-flood -j REJECT</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425082243493.png"
                      alt="image-20230425082243493"
                ></p>
<h2 id="数据包记录实验"><a href="#数据包记录实验" class="headerlink" title="数据包记录实验"></a>数据包记录实验</h2><h2 id="一-实验目的-18"><a href="#一-实验目的-18" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>理解入侵检测的作用和原理，掌握snort入侵检测的数据包记录的方法。</p>
<h2 id="二-实验原理-18"><a href="#二-实验原理-18" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>入侵检测是指对入侵行为的发现、报警和响应，它通过对计算机网络或计算机系统中的若干关键点收集信息并对其进行分析，从中发现网络或系统中是否有违反安全策略的行为和被攻击的迹象。</p>
<h2 id="三-实验内容-18"><a href="#三-实验内容-18" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>在Windows平台建立基于Snort的IDS，进行数据包记录实验并分析数据包</p>
<h2 id="四-实验环境描述-18"><a href="#四-实验环境描述-18" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>1、学生机与实验室网络直连2、VPC1与实验室网络直连3、学生机与VPC1物理链路连通</p>
<h2 id="五-实验步骤-18"><a href="#五-实验步骤-18" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、点击开始实验进入实验环境</p>
<p>2、输入默认账号administrator，密码123456，进入目标主机桌面。</p>
<p>3、打开d:＼tools目录，安装WinPcap_4_1_2.exe（按照向导提示安装即可）安装wireshark（按照向导默认安装即可）安装Snort_2_9_1_2_Installer.exe（默认安装即可）</p>
<p>4、安装完成后单击“开始”“运行”，输入“cmd”，打开命令行，</p>
<p>5、使用下面命令检测安装是否成功：<code>cd C:＼snort＼bin (回车)   Snort –W </code>如果出现小猪的形状就说明安装成功了，此时，snort已经可以用于嗅探模式了。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425082809933.png"
                      alt="image-20230425082809933"
                >6、输入嗅探模式命令snort –i 1（此处选择1是网卡选择，由上图可以看出1号网卡有可用的IP地址） <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425082958420.png"
                      alt="image-20230425082958420"
                >7、Snort数据包记录器模式上面介绍的嗅探器模式只是把信息显示在屏幕上，如果要把这些数据信息记录到硬盘上并制定到一个目录中，那就需要使用数据包记录器模式。进入dos界面，C:＼snort＼bin目录下运行命令（具体过程见4、5步）：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425083130453.png"
                      alt="image-20230425083130453"
                >8、进入Snort包记录器模式。可以到c:＼Snort＼log 下查看Snort记录的数据包（用wireshark查看)：snort.log.<strong><em>*</em>*</strong> 文件。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425083324412.png"
                      alt="image-20230425083324412"
                > 9、以上就是通过Snort获取的数据包，可简单分析日志记录的数据包。</p>
<p>10、实验完成，关闭程序和虚拟机。</p>
<h2 id="入侵行为检测实验"><a href="#入侵行为检测实验" class="headerlink" title="入侵行为检测实验"></a>入侵行为检测实验</h2><h2 id="一-实验目的-19"><a href="#一-实验目的-19" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h2><p>理解入侵检测的作用和原理，掌握snort入侵检测的方法</p>
<h2 id="二-实验原理-19"><a href="#二-实验原理-19" class="headerlink" title="二. 实验原理"></a>二. 实验原理</h2><p>掌握snort入侵检测规则格式</p>
<h2 id="三-实验内容-19"><a href="#三-实验内容-19" class="headerlink" title="三. 实验内容"></a>三. 实验内容</h2><p>在Windows平台建立基于Snort的IDS，进行入侵行为检测实验。</p>
<h2 id="四-实验环境描述-19"><a href="#四-实验环境描述-19" class="headerlink" title="四. 实验环境描述"></a>四. 实验环境描述</h2><p>1、学生机与实验室网络直连2、VPC1与实验室网络直连3、学生机与VPC1物理链路连通</p>
<h2 id="五-实验步骤-19"><a href="#五-实验步骤-19" class="headerlink" title="五. 实验步骤"></a>五. 实验步骤</h2><p>1、点击开始实验，进入实验环境<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/846e312bbe074e639aa52b2a04060ee5.png"
                      alt="图片描述"
                >2、安装WinPcap_4_1_2.exe（按照向导提示安装即可)</p>
<p>3、安装Snort_2_9_1_2_Installer.exe（默认安装即可）4、安装完成后单击“开始”“运行”，输入“cmd”，打开命令行</p>
<p>5、使用下面命令检测安装是否成功：<code>cd C:＼snort＼bin (回车)   Snort –W</code>如果出现小猪的形状就说明安装成功了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425083917655.png"
                      alt="image-20230425083917655"
                ></p>
<p>6、将d:＼tools＼snortrules-snapshot-2903.tar.gz解压，并将文件夹里面的文件全部拷贝覆盖到c:＼Snort下，复制的时候会出现重复的文件，重复的数据全部替换掉，修改snort配置文件 etc里面的snort.conf文件。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/99892c051bd53d1ec8acdc47252671ab.png"
                      alt="图片描述"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">原：var RULE_PATH ../rules 改为: var RULE_PATH C:＼Snort＼rules  </span><br><span class="line">原: #dynamicpreprocessor directory /usr/local/lib/snort_dynamicpreprocessor/ 改为:dynamicpreprocessor directory C:＼Snort＼lib＼snort_dynamicpreprocessor(后面一定不要有/)  </span><br><span class="line">原: #dynamicengine /usr/local/lib/snort_dynamicengine/libsf_engine.so 改为:dynamicengine C:＼Snort＼lib＼snort_dynamicengine＼sf_engine.dll  </span><br><span class="line">原：dynamicdetection directory /usr/local/lib/snort_dynamicrules 改为：dynamicdetection directory C:＼Snort＼lib＼snort_dynamicrules </span><br><span class="line">然后将C:Snort＼so_rules＼precompiled＼FC-9＼i386＼2.9.0.3里的所有文件拷贝到C:＼Snort＼lib＼snort_dynamicrules（该文件需要新建snort_dynamicrules） </span><br><span class="line">还需要修改c:＼snort配置文件 etc里面的snort.conf文件 原: include classification.config 改为: include C:＼Snort＼etc＼classification.config  </span><br><span class="line">原: include reference.config 改为: include C:＼Snort＼etc＼reference.config  </span><br><span class="line">原: # include threshold.conf 改为: include C:＼Snort＼etc＼threshold.conf  </span><br><span class="line">原：#Does nothing in IDS mode preprocessor normalize_ip4 preprocessor normalize_tcp: ips ecn stream preprocessor normalize_icmp4 preprocessor normalize_ip6 preprocessor normalize_icmp6 改成 #preprocessor normalize_ip4 #preprocessor normalize_tcp: ips ecn stream #preprocessor normalize_icmp4 #preprocessor normalize_ip6 #preprocessor normalize_icmp6 </span><br><span class="line">原：preprocessor http_inspect: global iis_unicode_map unicode.map 1252 compress_depth 20480 decompress_depth 20480 改为：preprocessor http_inspect: global iis_unicode_map C:＼Snort＼etc＼unicode.map 1252 compress_depth 65535 decompress_depth 65535（因为在windows下unicode.map这个文件在etc文件夹下。</span><br><span class="line">将compress_depth 和decompress_depth 设置compress_depth 65535 decompress_depth 65535） 将所有的ipvar修改为var 将#include $RULE_PATH/web-misc.rules注释掉。 ``进入dos，</span><br><span class="line">在＼snort＼bin目录用snort -W查看系统可用网络接口。记住需要监视的网卡的编号，比如为1，那么在以后的使用中，用-i 1就可以选择对应的网卡。</span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425091817286.png"
                      alt="image-20230425091817286"
                ></p>
<p>7、运行命令 <code>snort –i 1 -c ＂c:＼Snort＼etc＼snort.conf＂ -l ＂c:＼snort＼log</code>＂，此时为攻击检测模式。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/f4bc2d320b6b0f083953faaa0c26de6b.png"
                      alt="图片描述"
                >8、ctrl+c停止检测后，到c:＼snort＼log目录下可以查看日志报告。名为alert的文件即为检测报告（可用记事本打开)。9、分析生成的检测报告。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="F:/ScreenShotTools/images/image-20230425092315850.png"
                      alt="image-20230425092315850"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">snort_dynamicrules</span><br></pre></td></tr></table></figure></div>]]></content>
  </entry>
</search>
